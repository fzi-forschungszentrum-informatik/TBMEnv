#!/usr/bin/env python3
"""
"""
from datetime import time, timedelta
from pathlib import Path

import numpy as np
import pandas as pd


DATA_DIR = Path(__file__).parent / "data"


class TBMEnv:
    """
    Parent class holding shared code for both scenarios.
    """

    predicted_means = []

    def __init__(self):
        """
        Prepare the env.

        Generates Attributes:
        ---------------------
        data : pandas.DataFrame
            The dataset for the env.
            Is generated by calling `self.load_data`
        obs_selectors : dict of pandas.Timestamp -> pandas.Timestamp
            Selectors for the obs data.
            Is generated by calling `self.make_selectors`
        ac_dist_selectors dict of pandas.Timestamp -> pandas.Timestamp
            Selectors for the actions and disturbances.
            Is generated by calling `self.make_selectors`
        train_ts : list of pandas.Timestamp
            List of timestamps that belong to training dataset.
            Is generated by calling `self.make_selectors`
        eval_ts : list of pandas.Timestamp
            List of timestamps that belong to evaluation dataset.
            Is generated by calling `self.make_selectors`

        """
        self.load_data()
        self.make_selectors()

    def load_data(self):
        """
        Load the data for the scenario. To be overloaded.
        """
        raise NotImplementedError("`load_data` must be overloaded by child.")

    def make_selectors(self):
        """
        Create selectors for obs and actions/disturbances.

        Selectors match a timestamp (i.e. the state of the environment
        to one or more timestamps that correspond to the data that
        should be returned by `self.step` for that timestamp.
        """
        raise NotImplementedError(
            "`make_selectors` must be overloaded by child."
        )

    def get_training_data(self):
        """
        Returns the training data that should be used by the canidate models.

        Returns:
        --------
        training_obs : list of pandas.DataFrame
            A list of obs items as would be returned by `self.step`.
        training_actions : list of pandas.DataFrame
            A list of action items as would be returned by `self.step`
        training_disturbances : list of pandas.DataFrame
            A list of disturbance items as would be returned by `self.step`
        """
        training_obs = []
        training_actions = []
        training_disturbances = []

        for ts in self.train_ts:
            obs, actions, disturbances = self.get_step_return_for_ts(ts)

            training_obs.append(obs)
            training_actions.append(actions)
            training_disturbances.append(disturbances)

        return training_obs, training_actions, training_disturbances

    def get_step_return_for_ts(self, ts):
        """
        Computes the stuff returned by `self.step` for a particular timestamp.

        Arguments:
        ----------
        ts : pandas.Timestamp


        Returns:
        --------
        obs : pandas.DataFrame
            The observed values corresponding to the state variables to
            predict that would have been generated since the last step.
        actions : pandas.DataFrame
            The actions that should be considered in the state prediction.
        disturbances : pandas.DataFrame
            The forcast of disturbances that should be considered in the
            state prediction.
        """
        obs_selector = self.obs_selectors[ts]
        ac_dist_selector = self.ac_dist_selectors[ts]

        obs = self.data.loc[obs_selector, self.obs_columns]
        actions = self.data.loc[ac_dist_selector, self.action_columns]
        disturbances = self.data.loc[ac_dist_selector, self.disturbance_columns]

        return obs, actions, disturbances

    def reset(self):
        """
        Reset the environment to the intial state.
        """
        self.i_eval = 0
        self.all_predicted_states = []

        ts = self.eval_ts[self.i_eval]
        return self.get_step_return_for_ts(ts)

    def step(self, predicted_states):
        """
        Advance the environment by one step.

        This stores the `predicted_states` for computing the performance
        measure later and returns the data required for the next prediction
        step.

        Arguments:
        ----------
        predicted_states : pandas.DataFrame
            A dataframe holding the candidate prediction of the state
            variables that should be predicted in the repsective scenario.

        Returns:
        --------
        obs : pandas.DataFrame
            The observed values corresponding to the state variables to
            predict that would have been generated since the last step.
        actions : pandas.DataFrame
            The actions that should be considered in the state prediction.
        disturbances : pandas.DataFrame
            The forcast of disturbances that should be considered in the
            state prediction.
        done : bool
            If true the final state has been reached.
        """
        if not hasattr(self, "i_eval"):
            raise RuntimeError("Reset env before calling step.")

        # Note that the data for the current `i_eval` has already been
        # provided to the canidate model, i.e. by `reset` if this is the
        # first call to `step`.
        if self.i_eval >= len(self.eval_ts) - 1:
            # Don't increment `i_eval` further if maximum reached to prevent
            # IndexError while fetching the ts below.
            done = True
        else:
            done = False
            self.i_eval += 1

        ts = self.eval_ts[self.i_eval]
        obs, actions, disturbances = self.get_step_return_for_ts(ts)

        self.all_predicted_states.append(predicted_states)

        return obs, actions, disturbances, done

    def compute_performance_measure(self, return_per_lead_step=False):
        """
        Computes the performance measure, i.e. the mean average error.

        Arguments:
        ----------
        return_per_lead_step : bool
            If true return the residual error per lead step instead
            of the performance measure. This might be of advantage for
            further analysis. See below for more details.

        Returns:
        --------
        performance_measure : float or numpy.ndarray
            `if not return_per_lead_step` then this is a float value
            representing the mean average error of the predictions.
            `if return_per_lead_step` then this is an array holding
            the (absolute) residuals with dim 3 and shape:
                0: Number of predictions, i.e. `len(self.all_predicted_states)`
                1: Number of time steps per forecast
                2: Number of predicted states, i.e. `len(self.obs_columns)`

        """
        all_p = self.all_predicted_states
        measured_states = self.data[self.obs_columns]
        residuals = [abs(measured_states - p).dropna() for p in all_p]
        residuals_per_lead_step = np.stack([r.values for r in residuals])

        # Verify that the candidate algorithm has provided all of the
        # expected predictions. This should prevent that the evaluation
        # has been aborted after few calls to `self.step`, which might
        # return an incorrect estimate of the performance measure.
        expected_shape = (
            self.n_predictions_expected,
            self.n_fct_steps_expected,
            len(self.obs_columns),
        )
        if expected_shape != residuals_per_lead_step.shape:
            raise ValueError(
                "It seems that the candidate algorithm has not provided "
                "predictions for all days or forecast steps. The env expected "
                f"shape and {expected_shape} but got "
                f"{residuals_per_lead_step.shape}."
                "See the docstring of `compute_performance_measure` for an "
                "explanation of the components of the shape."
            )

        if return_per_lead_step:
            return residuals_per_lead_step
        else:
            return residuals_per_lead_step.mean()

    def compute_mape(self):
        """
        Computes the Mean Average Percentage Error.


        Returns:
        --------
        mape : np.array
            MAPE per lead step.
        """
        all_p = self.all_predicted_states
        ms = self.data[self.obs_columns]
        percent_error = [abs((ms - p) / ms).dropna() * 100 for p in all_p]
        mape_per_lead_step = np.stack([r.values for r in percent_error])
        return mape_per_lead_step


class Scenario1(TBMEnv):

    obs_columns = ["T_zone_s", "T_zone_f", "T_zone_g"]
    action_columns = ["P_cool_cca"]
    disturbance_columns = ["Temperature", "Irradiance"]
    n_predictions_expected = 5760
    n_fct_steps_expected = 96

    def load_data(self):
        """
        Load the data for the scenario 2.
        """
        self.data = pd.read_csv(
            DATA_DIR / "scenario_1_data.csv.bz2",
            index_col=0,
            parse_dates=True,
        )

    def make_selectors(self):
        """
        Create selectors for obs and actions/disturbances.

        Selectors match a timestamp (i.e. the state of the environment
        to one or more timestamps that correspond to the data that
        should be returned by `self.step` for that timestamp.
        """
        obs_selectors = {}
        ac_dist_selectors = {}
        train_ts = []
        eval_ts = []

        for i in range(len(self.data.index) - 96):
            ts = self.data.index[i]
            obs_selectors[ts] = [ts]
            # fmt: off
            ac_dist_selectors[ts] = self.data.index[i:i+97]
            # fmt: on

            if ts.month < 8:
                train_ts.append(ts)
            else:
                eval_ts.append(ts)

        self.obs_selectors = obs_selectors
        self.ac_dist_selectors = ac_dist_selectors
        self.train_ts = train_ts
        self.eval_ts = eval_ts


class Scenario2(TBMEnv):

    obs_columns = ["T_z"]
    action_columns = ["T_zSP"]
    disturbance_columns = [
        "T_a",
        "T_s_fct_mean",
        "T_s_fct_lower",
        "T_s_fct_upper",
        "CO2_fct_mean",
        "CO2_fct_upper",
        "CO2_fct_lower",
    ]
    n_predictions_expected = 57
    n_fct_steps_expected = 144

    def load_data(self):
        """
        Load the data for the scenario 2.
        """
        self.data = pd.read_csv(
            DATA_DIR / "scenario_2_data.csv.bz2",
            index_col=0,
            parse_dates=True,
        )
        # Add setpoints, these have not been recorded but have
        # defined in the TropicalPrecooling env like this.
        self.data["T_zSP"] = None
        self.data.loc[self.data.index.time >= time(6, 45), "T_zSP"] = 23.5

    def make_selectors(self):
        """
        Create selectors for obs and actions/disturbances.

        Selectors match a timestamp (i.e. the state of the environment
        to one or more timestamps that correspond to the data that
        should be returned by `self.step` for that timestamp.
        """
        obs_selectors = {}
        ac_dist_selectors = {}
        train_ts = []
        eval_ts = []

        first_ts_of_day = self.data.loc[time(4, 2, 30)].index

        for i in range(1, len(first_ts_of_day)):
            ts_previous_day = first_ts_of_day[i - 1]
            ts_present_day = first_ts_of_day[i]

            # Select obs from 5am last day to 5am next day.
            # The first hour of the evaluated day is for the thermal
            # model to estimate the building state before making predictions.
            obs_selectors[ts_present_day] = self.data.index[
                np.logical_and(
                    self.data.index >= ts_previous_day + timedelta(hours=1),
                    self.data.index < ts_present_day + timedelta(hours=1),
                )
            ]

            ac_dist_selectors[ts_present_day] = self.data.index[
                self.data.index.date == ts_present_day.date()
            ]

            #
            if ts_present_day.month < 7:
                train_ts.append(ts_present_day)
            else:
                eval_ts.append(ts_present_day)

        self.obs_selectors = obs_selectors
        self.ac_dist_selectors = ac_dist_selectors
        self.train_ts = train_ts
        self.eval_ts = eval_ts
